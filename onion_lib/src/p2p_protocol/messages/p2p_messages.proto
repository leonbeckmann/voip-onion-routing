syntax = "proto3";

// P2P Onion Tunnel frame
message TunnelFrame {
  // an identifier for identifying the corresponding tunnel of this frame
  fixed32 frame_id = 1;

  // random, unpredictable iv used for encryption
  bytes iv = 2;

  // auth_tag | FrameData as bytes (encrypted)
  bytes data = 3;
}

message FrameData {
  fixed32 data_size = 1;
  bool app_data = 2;
  bytes data = 3;
}

message FrameDataType {
  oneof message {
    HandshakeData handshake_data = 1;
    ApplicationData app_data = 2;
  }
}

message HandshakeData {
  // establish secure channel
  oneof message {
    ClientHello client_hello = 1;
    ServerHello server_hello = 2;
    RoutingInformation routing = 3;
  }
}

message ClientHello {
  // frameId used for communicating with the source
  uint32 backward_frame_id = 1;
  bytes ecdh_public_key = 2;
}

message ServerHello {
  // public ECDHE parameter
  bytes ecdh_public_key = 1;
  // challenge for client authentication
  bytes challenge = 2;
  // iv for encrypted data
  bytes iv = 3;
  // encrypted data
  bytes encrypted_data = 4;
}

message EncryptedServerHelloData {
  bytes signature = 1;
  // used for hops to tell next hop how to address prev hop
  uint32 backward_frame_id = 2;
  repeated uint32 backward_frame_ids = 3;
  repeated uint32 forward_frame_ids = 4;
}

message RoutingInformation {
  bool is_endpoint = 1;
  bytes next_hop_addr = 2;
  uint32 next_hop_port = 3;

  oneof optional_challenge_response {
    bytes challenge_response = 4;
  }

  repeated uint32 backward_frame_ids = 5;
  uint32 tunnel_update_reference = 6;
  bool cover_only = 7;
}

message ApplicationData {
  fixed32 sequence_number = 1;
  oneof message {
    bytes data = 2;
    CoverTraffic cover_traffic = 3;
    Close close = 4;
  }
}

message CoverTraffic {
  bytes data = 1;
  bool mirrored = 2;
}

message Close {}
